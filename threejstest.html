<html>
	<head>
		<meta charset="utf-8">
		<title>Particle Visualization</title>
		<style>
			* {
				-webkit-box-sizing: border-box;
			     -moz-box-sizing: border-box;
			          box-sizing: border-box;
			}

			section {
				margin: auto;
				height: 610px;
			}

			#cylinder {
				width: 410px;
				height: 610px;
				border: solid #d3d3d3 5px;
				float: left;
			}

			#svg {
				width: 410px;
				height: 610px;
				border: solid #d3d3d3 5px;
				position: relative;
				left: 415px;
			}

			#general {

			}

			body {
				background-color: #aaa;
			}
		</style>
	</head>
	<body>
		<section>
			<div id="cylinder"></div>
			<div id="svg"></div>
		</section>
		<script src="//d3js.org/d3.v3.min.js"></script>
		<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r78/three.min.js"></script>

		<script>
			var WIDTH = 400,
				HEIGHT = 600;

			var folderPath = "clean.44/";
			var numFiles = 121;
			var data = [];
			var sliced = [];

			var filePick = 45;


			// needed for three.js to show anything
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, WIDTH/HEIGHT, 0.1, 1000 );

			var renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0x333333)
			renderer.setSize(WIDTH, HEIGHT);

			var container = document.getElementById('cylinder');
			// document.body.appendChild(container);

			container.appendChild( renderer.domElement );

			scene.add(camera);
			// camera.rotation.y = (Math.PI/2);
			// camera.rotation.x = (Math.PI/2);
			camera.rotation.z = Math.PI/4;
			camera.position.z = 10;
			camera.position.x = 15;
			camera.up = new THREE.Vector3(0, 0, 1);
			camera.lookAt(new THREE.Vector3(0, 0, 5));






			// add slice (6 lines)

			var sliceWidth = .25;

			var sliceGroup = new THREE.Group();

			var lineMat = new THREE.LineBasicMaterial({
				color: 0xAAAAAA
			});

			// FRONT
			var line1g = new THREE.Geometry();
			line1g.vertices.push(
				new THREE.Vector3(5,-(sliceWidth/2),10.25), new THREE.Vector3(5,-(sliceWidth/2),-0.25), new THREE.Vector3(5,(sliceWidth/2),-0.25), new THREE.Vector3(5,(sliceWidth/2),10.25), new THREE.Vector3(5,-(sliceWidth/2),10.25));

			// BACK
			var line5g = new THREE.Geometry();
			line5g.vertices.push(
				new THREE.Vector3(-5,-(sliceWidth/2),10.25), new THREE.Vector3(-5,-(sliceWidth/2),-0.25), new THREE.Vector3(-5,(sliceWidth/2),-0.25), new THREE.Vector3(-5,(sliceWidth/2),10.25), new THREE.Vector3(-5,-(sliceWidth/2),10.25));

			// SIDES
			var line9g = new THREE.Geometry();
			line9g.vertices.push(
				new THREE.Vector3(-5,-(sliceWidth/2),10.25), new THREE.Vector3(5,-(sliceWidth/2),10.25));

			var line10g = new THREE.Geometry();
			line10g.vertices.push(
				new THREE.Vector3(-5,(sliceWidth/2),10.25), new THREE.Vector3(5,(sliceWidth/2),10.25));

			var line11g = new THREE.Geometry();
			line11g.vertices.push(
				new THREE.Vector3(-5,-(sliceWidth/2),-0.25), new THREE.Vector3(5,-(sliceWidth/2),-0.25));

			var line12g = new THREE.Geometry();
			line12g.vertices.push(
				new THREE.Vector3(-5,(sliceWidth/2),-0.25), new THREE.Vector3(5,(sliceWidth/2),-0.25));

			// CREATE LINES

			var line1 = new THREE.Line(line1g, lineMat);

			var line5 = new THREE.Line(line5g, lineMat);

			var line9 = new THREE.Line(line9g, lineMat);
			var line10 = new THREE.Line(line10g, lineMat);
			var line11 = new THREE.Line(line11g, lineMat);
			var line12 = new THREE.Line(line12g, lineMat);

			// ADD TO SCENE
			sliceGroup.add(line1);

			sliceGroup.add(line5);

			sliceGroup.add(line9);
			sliceGroup.add(line10);
			sliceGroup.add(line11);
			sliceGroup.add(line12);

			scene.add(sliceGroup);



			// add slice (box wireframe)
			/*
			var boxGeo = new THREE.BoxGeometry(10, .5, 10.25);
			var boxMat = new THREE.MeshBasicMaterial( {color: 0xbbbbbb, opacity: 0, transparent: true});
			var box = new THREE.Mesh(boxGeo, boxMat);
			box.position.z = 5.125;

			var boxWire = new THREE.WireframeHelper(box, 0xffffff);

			scene.add(box);
			scene.add(boxWire);
			*/

			// render scene

			var particleSystem;
			var currentRotation = 0;

			var myClock = new THREE.Clock();

			function render() {
				requestAnimationFrame( render );

				if(particleSystem) {

					currentRotation = (currentRotation + myClock.getDelta() /2) % (2*Math.PI);
					particleSystem.rotation.z = currentRotation;


					sliced = [];
					for(var i = 0; i < data.length; i++){
						var loc = new THREE.Vector3(data[i].Points0, data[i].Points1, data[i].Points2);
						loc.applyAxisAngle(new THREE.Vector3(0,0,1), currentRotation);
						if(loc.y > (sliceGroup.position.y - (sliceWidth/2)) && loc.y < (sliceGroup.position.y + (sliceWidth/2)))
						{
							sliced.push({num: i, position: loc, concentration: data[i].concentration});
						}
					}
				}

				renderer.render( scene, camera );
			}

			function onWindowResize(){
				camera.updateProjectionMatrix();
				renderer.setSize(500,500);
			}


			// MOVE TO CALLBACK FROM FILE READ VV
			var maxConc;

			var color = d3.scale.quantile()
				.range([0x000004,0x010005,0x010106,0x010108,0x020109,0x02020b,0x02020d,0x03030f,0x030312,0x040414,0x050416,0x060518,0x06051a,0x07061c,0x08071e,0x090720,0x0a0822,0x0b0924,0x0c0926,0x0d0a29,0x0e0b2b,0x100b2d,0x110c2f,0x120d31,0x130d34,0x140e36,0x150e38,0x160f3b,0x180f3d,0x19103f,0x1a1042,0x1c1044,0x1d1147,0x1e1149,0x20114b,0x21114e,0x221150,0x241253,0x251255,0x271258,0x29115a,0x2a115c,0x2c115f,0x2d1161,0x2f1163,0x311165,0x331067,0x341069,0x36106b,0x38106c,0x390f6e,0x3b0f70,0x3d0f71,0x3f0f72,0x400f74,0x420f75,0x440f76,0x451077,0x471078,0x491078,0x4a1079,0x4c117a,0x4e117b,0x4f127b,0x51127c,0x52137c,0x54137d,0x56147d,0x57157e,0x59157e,0x5a167e,0x5c167f,0x5d177f,0x5f187f,0x601880,0x621980,0x641a80,0x651a80,0x671b80,0x681c81,0x6a1c81,0x6b1d81,0x6d1d81,0x6e1e81,0x701f81,0x721f81,0x732081,0x752181,0x762181,0x782281,0x792282,0x7b2382,0x7c2382,0x7e2482,0x802582,0x812581,0x832681,0x842681,0x862781,0x882781,0x892881,0x8b2981,0x8c2981,0x8e2a81,0x902a81,0x912b81,0x932b80,0x942c80,0x962c80,0x982d80,0x992d80,0x9b2e7f,0x9c2e7f,0x9e2f7f,0xa02f7f,0xa1307e,0xa3307e,0xa5317e,0xa6317d,0xa8327d,0xaa337d,0xab337c,0xad347c,0xae347b,0xb0357b,0xb2357b,0xb3367a,0xb5367a,0xb73779,0xb83779,0xba3878,0xbc3978,0xbd3977,0xbf3a77,0xc03a76,0xc23b75,0xc43c75,0xc53c74,0xc73d73,0xc83e73,0xca3e72,0xcc3f71,0xcd4071,0xcf4070,0xd0416f,0xd2426f,0xd3436e,0xd5446d,0xd6456c,0xd8456c,0xd9466b,0xdb476a,0xdc4869,0xde4968,0xdf4a68,0xe04c67,0xe24d66,0xe34e65,0xe44f64,0xe55064,0xe75263,0xe85362,0xe95462,0xea5661,0xeb5760,0xec5860,0xed5a5f,0xee5b5e,0xef5d5e,0xf05f5e,0xf1605d,0xf2625d,0xf2645c,0xf3655c,0xf4675c,0xf4695c,0xf56b5c,0xf66c5c,0xf66e5c,0xf7705c,0xf7725c,0xf8745c,0xf8765c,0xf9785d,0xf9795d,0xf97b5d,0xfa7d5e,0xfa7f5e,0xfa815f,0xfb835f,0xfb8560,0xfb8761,0xfc8961,0xfc8a62,0xfc8c63,0xfc8e64,0xfc9065,0xfd9266,0xfd9467,0xfd9668,0xfd9869,0xfd9a6a,0xfd9b6b,0xfe9d6c,0xfe9f6d,0xfea16e,0xfea36f,0xfea571,0xfea772,0xfea973,0xfeaa74,0xfeac76,0xfeae77,0xfeb078,0xfeb27a,0xfeb47b,0xfeb67c,0xfeb77e,0xfeb97f,0xfebb81,0xfebd82,0xfebf84,0xfec185,0xfec287,0xfec488,0xfec68a,0xfec88c,0xfeca8d,0xfecc8f,0xfecd90,0xfecf92,0xfed194,0xfed395,0xfed597,0xfed799,0xfed89a,0xfdda9c,0xfddc9e,0xfddea0,0xfde0a1,0xfde2a3,0xfde3a5,0xfde5a7,0xfde7a9,0xfde9aa,0xfdebac,0xfcecae,0xfceeb0,0xfcf0b2,0xfcf2b4,0xfcf4b6,0xfcf6b8,0xfcf7b9,0xfcf9bb,0xfcfbbd,0xfcfdbf]);


			var particles,
				pMaterial = new THREE.PointsMaterial({
							size: .15,
							vertexColors: THREE.VertexColors,
							//map: new THREE.TextureLoader().load("ball.png"),
							//blending: THREE.AdditiveBlending,
							//transparent: true
						});

			function drawParticles(fileNum) {

				scene.remove(particleSystem);
				particleSystem = null;
				if(particles) particles.dispose();


				maxConc = d3.max(data, function(el) {
					return el.concentration;
				});

				color.domain([0, maxConc]);

				var particleCount = data.length, // 40th step
					particles = new THREE.Geometry();

				// now create the individual particles
				for(var p = 0; p < particleCount; p++) {

					// create a particle with random
					// position values, -250 -> 250
					var pX = data[p].Points0,
						pY = data[p].Points1,
						pZ = data[p].concentration < .75 ? -40 : data[p].Points2,
						// pZ = data[fileNum][p].Points2,
					    particle = new THREE.Vector3(pX, pY, pZ);

					// add it to the geometry
					particles.vertices.push(particle);

				}

				// create the particle system
				particleSystem = new THREE.Points(
					particles,
					pMaterial);

				for(var p = 0; p < particleCount; p++) {
					particleSystem.geometry.colors[p] = new THREE.Color(color(Number(data[p].concentration)));
					//particleSystem.geometry.colors[p].setHSL(color(data[p].concentration), 1, 0.5);

				}

				particleSystem.geometry.colorsNeedUpdate = true;

				particleSystem.sortParticles = true;

				// add it to the scene
				scene.add(particleSystem);
				particleSystem.rotation.z = currentRotation;


				// render again after particles created
				render();

				//setTimeout(function(){return drawParticles((fileNum+1)%numFiles); }, 5000);
			}



			// file reading

			// read all files
			// readFileNumCSV(0, numFiles);
			// read 1 file
			readFileNumCSV(filePick, filePick+1);


			//readFileNumCSV(23, 24);
			//readFileNumJSON(0);


			function readFileNumCSV(n, end) {

				d3.csv(folderPath + ('000' + n).substr(-3) + ".csv")
					.row(function(d) {

						var el = {
							concentration: Number(d.concentration),
							Points0: Number(d.Points0),
							Points1: Number(d.Points1),
							Points2: Number(d.Points2)

						};

						data.push(el);
					})
					.get(function(error, rows) {
						/*
						console.log(n, ":", d3.mean(data[n], function(d){
							return d.concentration;
						}));
						*/
						console.log(n, "read (CSV).");
						drawParticles(n);
						render();
						if(n+1 < end) {

							//setTimeout(function(){return readFileNumCSV(n+1, end);}, 5000);
						}
						else {
							console.log("done");
							//setTimeout(function(){return readFileNumCSV(20, end);}, 5000);
						}
					});

			}

			function readFileNumJSON(n) {

				d3.csv(folderPath + ('000' + n).substr(-3) + ".json", function(error, json) {
						data = json;
						console.log(n, "read (JSON).");

						render();
						drawParticles(n);
					});

			}

			function downloadJSON(data2JSON) {
			    var json = JSON.stringify(data2JSON)

				var csvWin = window.open("","","");
				csvWin.document.write('<meta name="content-type" content="text/csv">');
				csvWin.document.write('<meta name="content-disposition" content="attachment;  filename=test.csv">  ');
				csvWin.document.write(json);
			}

		</script>
	</body>
</html>
